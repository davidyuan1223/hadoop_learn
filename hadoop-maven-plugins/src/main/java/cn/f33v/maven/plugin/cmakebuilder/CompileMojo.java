package cn.f33v.maven.plugin.cmakebuilder;

import cn.f33v.maven.plugin.util.Exec;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;

import java.io.File;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * @Description: 实现选择如何构建本地source
 * @Author: yuan
 * @Date: 2023/07/11
 **/
@Mojo(name = "cmake-compile",defaultPhase = LifecyclePhase.COMPILE)
public class CompileMojo extends AbstractMojo {
    public static int availableProcessors=Runtime.getRuntime().availableProcessors();
    /**
     * 构建位置
     */
    @Parameter(defaultValue = "${project.build.directory}/native")
    private File output;
    /**
     * locations of the source files
     * this should be where the resources are checked in
     */
    @Parameter(defaultValue = "${basedir}/src/main/native",required = true)
    private File source;
    /**
     * CMake build target
     */
    @Parameter
    private String target;
    /**
     * Environment variable to pass to CMake
     * Note that it is usually better to use a CMake variable than an environment
     * variable.To quote the CMake FAQ:
     * "One should avoid using environment variable for controlling the flow of
     * CMake code (such as in IF commands).The build system generated by CMake
     * may re-run CMake automatically when CMakeLists.txt files change.The
     * environment in which this is executed is controlled by the build system and
     * may not match that in which CMake was originally run.If you want to control
     * build settings on the CMake command line,you need to use cache variables
     * set with the -D option.The settings will be saved in CMakeCache.txt so that
     * they don't have to be repeated every time CMake is run on the same build tree."
     */
    @Parameter
    private Map<String ,String > env;
    /**
     * CMake cached variable to set
     */
    @Parameter
    private Map<String ,String > vars;
    // TODO: support Windows
    private static void validatePlatform() throws MojoExecutionException {
        if (System.getProperty("os.name").toLowerCase(Locale.ENGLISH).startsWith("windows")) {
            throw new MojoExecutionException("CMakeBuilder does not yet support the Windows platform.");
        }
    }

    @Override
    public void execute() throws MojoExecutionException, MojoFailureException {
        long start = System.nanoTime();
        validatePlatform();
        runCMake();
        runMake();
        long end = System.nanoTime();
        getLog().info("cmake compilation finished successfully in "+
                TimeUnit.MILLISECONDS.convert(end-start,TimeUnit.NANOSECONDS)
        +"millisecond(s)");
    }
    /**
     * validate that source parameters lock sane
     */
    static void validateSourceParams(File source,File output) throws MojoExecutionException {
        String cOutput=null,cSource=null;
        try {
            cOutput=output.getCanonicalPath();
        }catch (IOException e){
            throw new MojoExecutionException("error getting canonical path for output",e);
        }
        try {
            cSource=source.getCanonicalPath();
        } catch (IOException e) {
            throw new MojoExecutionException("error getting canonical path for source",e);
        }
        // This doesn't catch all the bad cases-- we could be following symlinks or hardlinks
        // etc. However,this will usually catch a common mistake
        if (cSource.startsWith(cOutput)) {
            throw new MojoExecutionException("The source directory must not be inside the output directory (it would be destroyed by 'mvn clean'");
        }
    }
    public void runCMake()throws MojoExecutionException{
        validatePlatform();
        validateSourceParams(source,output);
        if (output.mkdirs()) {
            getLog().info("mkdirs '"+output+"'");
        }
        List<String > cmd=new LinkedList<>();
        cmd.add("cmake");
        cmd.add(source.getAbsolutePath());
        for (Map.Entry<String, String> entry : vars.entrySet()) {
            if ((entry.getValue() != null) && (!entry.getValue().equals(""))) {
                cmd.add("-D"+entry.getKey()+"="+entry.getValue());
            }
        }
        cmd.add("-G");
        cmd.add("Unix Makefiles");
        String prefix="";
        StringBuilder stringBuilder = new StringBuilder();
        for (String s : cmd) {
            stringBuilder.append(prefix).append(s);
            prefix=" ";
        }
        getLog().info("Running "+stringBuilder.toString());
        getLog().info("with extra environment variables "+ Exec.envToString(env));
        ProcessBuilder processBuilder = new ProcessBuilder(cmd);
        processBuilder.directory(output);
        processBuilder.redirectErrorStream(true);
        Exec.addEnvironment(processBuilder,env);
        Process process=null;
        Exec.OutputBufferedThread outThread=null;
        int retCode=1;
        try {
            process=processBuilder.start();
            outThread=new Exec.OutputBufferedThread(process.getInputStream());
            outThread.start();
            retCode=process.waitFor();
            if (retCode != 0) {
                throw new MojoExecutionException("CMake failed with error code "+retCode);
            }
        }catch (IOException e){
            throw new MojoExecutionException("Error execution CMake",e);
        }catch (InterruptedException e){
            throw new MojoExecutionException("Interrupted while waiting for CMake process",e);
        }finally {
            if (process != null) {
                process.destroy();
            }
            if (outThread != null) {
                try {
                    outThread.interrupt();
                    outThread.join();
                }catch (InterruptedException e){
                    getLog().error("Interrupted while joining output thread", e);
                }
                if (retCode != 0) {
                    for (String line : outThread.getOutput()) {
                        getLog().warn(line);
                    }
                }
            }
        }
    }
    public void runMake()throws MojoExecutionException{
        List<String > cmd=new LinkedList<>();
        cmd.add("make");
        cmd.add("-j");
        cmd.add(String.valueOf(availableProcessors));
        cmd.add("VERSION=1");
        if (target != null) {
            cmd.add(target);
        }
        StringBuilder stringBuilder = new StringBuilder();
        String prefix="";
        for (String s : cmd) {
            stringBuilder.append(prefix).append(s);
            prefix=" ";
        }
        getLog().info("Running "+stringBuilder.toString());
        ProcessBuilder processBuilder = new ProcessBuilder(cmd);
        processBuilder.directory(output);
        Process process=null;
        int retCode=-1;
        Exec.OutputBufferedThread stdoutThread=null,stderrThread=null;
        try {
            process=processBuilder.start();
            stdoutThread=new Exec.OutputBufferedThread(process.getInputStream());
            stderrThread=new Exec.OutputBufferedThread(process.getInputStream());
            stdoutThread.start();
            stderrThread.start();
            retCode=process.waitFor();
            if (retCode != 0) {
                throw new MojoExecutionException("make failed with error code "+retCode);
            }
        }catch (InterruptedException e){
            throw new MojoExecutionException("Interrupted during Process#waitFor",e);
        }catch (IOException e){
            throw new MojoExecutionException("Error executing make",e);
        }finally {
            if (stdoutThread != null) {
                try {
                    stdoutThread.join();
                }catch (InterruptedException e){
                    getLog().error("Interrupted while joining stdoutThread",e);
                }
                if (retCode != 0) {
                    for (String line : stdoutThread.getOutput()) {
                        getLog().warn(line);
                    }
                }
            }
            if (stderrThread != null) {
                try{
                    stderrThread.join();
                }catch (InterruptedException e){
                    getLog().error("Interrupted while joining stderrThread",e);
                }
                for (String line : stderrThread.getOutput()) {
                    getLog().warn(line);
                }
            }
            if (process != null) {
                process.destroy();
            }
        }
    }
}
